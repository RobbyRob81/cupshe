//
//  PKMIMEMessage.m
//
//  Created by Jeff Hay on 3/29/12.
//  Copyright (c) 2012 Portable Knowledge, LLC. All rights reserved.
//
// Portable Knowledge Open Source Component License - Version 1.0 - April 13th, 2012
// 
// Permission is hereby granted, free of charge, to any person or organization`
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.  IN NO CASE DOES THE USE OF THIS SOFTWARE EXPRESS
// OR IMPLY ANY PARTNERSHIP OR COOPERATION WITH THE AUTHORS OR COPYRIGHT HOLDERS
// OF THIS SOFTWARE.


#import "PKMIMEMessage.h"

#import "NSString+GUID.h"

@implementation PKMIMEMessage

@dynamic transferEncoding, contentID, contentType, headers;

@dynamic boundary;

#pragma mark - Lifecycle

-(id) init
{
    if ((self = [super init]) != nil)
    {
        _parts = [[NSMutableArray alloc] initWithCapacity:1];
        _base = [[PKMIMEData alloc] init];
        _base.contentType = [PKContentType contentTypeFromString:@"multipart/mixed"];
     
        _rootIndex = 0;
    }
    return self;
}

-(id) initWithContentType:(PKContentType *)contentType
{
    if ([self init] != nil)
    {
        _base.contentType = contentType;
    }
    return self;
}

+(PKMIMEMessage *) messageWithData:(PKMIMEData *)data
{
    if (data == nil)
        return nil;
    
    PKMIMEMessage *message = [[PKMIMEMessage alloc] initWithContentType:data.contentType];

    // Add the data to our message, separating it into parts if it's multipart data
    if (data.contentType.isMultipart)
    {
        NSData *dataBytes = data.data;
        //in one test situation \r\n causes problem. without this works
        //NSData *boundary = [[NSString stringWithFormat:@"\r\n--%@", data.contentType.boundary] dataUsingEncoding:NSUTF8StringEncoding];
        NSData *boundary = [[NSString stringWithFormat:@"--%@", data.contentType.boundary] dataUsingEncoding:NSUTF8StringEncoding];
        
        NSRange searchRange;
        searchRange.location = 0;
        searchRange.length = dataBytes.length;
        
        NSRange partRange = [dataBytes rangeOfData:boundary options:0 range:searchRange];
        while ((partRange.location != NSNotFound) && (searchRange.length > 0))
        {
            // Find the next part, seperated by "boundary"
            // NOTE: Doesn't properly ignore data after the final boundary indicator
            searchRange.location = partRange.location + boundary.length;
            searchRange.length = dataBytes.length - searchRange.location;            
            NSRange nextPartRange = [dataBytes rangeOfData:boundary options:0 range:searchRange];
            
            if (nextPartRange.location != NSNotFound)
            {
                // Within this part, we have a series of headers seperated from the body by two sets of CRLF...
                partRange.location = searchRange.location;
                partRange.length = (nextPartRange.location - searchRange.location);
            
                NSData *headerSep = [@"\r\n\r\n" dataUsingEncoding:NSUTF8StringEncoding];
                NSRange headerRange = [dataBytes rangeOfData:headerSep options:0 range:partRange];
                
                NSString *partHeaders = nil;
                if (headerRange.location != NSNotFound)
                {
                    // Extract the header text
                    headerRange.length = headerRange.location - partRange.location;
                    headerRange.location = partRange.location;                       
                    partHeaders = [[NSString alloc] initWithData:[dataBytes subdataWithRange:headerRange] encoding:NSUTF8StringEncoding];
                    
                    // Adjust partRange to be just the data portion (without the headers)
                    partRange.location = headerRange.location + headerRange.length + 4;
                    partRange.length = partRange.length - headerRange.length - 4;
                }
                
                NSData *partData = [dataBytes subdataWithRange:partRange];
                [message addPart:[PKMIMEData dataFromData:partData andHeaders:[PKMIMEData headersFromStrings:partHeaders]]];
            }
            
            partRange = nextPartRange;
        }
            
        // If we're multipart/alternative, set the default part to the LAST part (should be most faithful per RFC 2045)
        // Otherwise, the default root part is the FIRST part 
        if ([data.contentType.subType isEqualToString:@"alternative"])
            [message setRootIndex:(message.numParts - 1)];
        else
            [message setRootIndex:0];
        
        // If our data supplies a root part indicator, use it to override the default root (i.e., for multipart/related)
        [message setRootContentID:[data.contentType parameterWithName:@"start"]];
    }
    else
        [message addPart:data];
    
    return message;
}


#pragma mark - Base Property Accessors (passthrough to _base or root)

-(NSMutableDictionary *) headers
{
    if (_base.contentType.isMultipart)
        return _base.headers;
    else
        return self.rootData.headers;
    return _base.headers;
}

-(PKContentType *) contentType
{
    if (_base.contentType.isMultipart)
        return _base.contentType;
    else
        return self.rootData.contentType;
}

-(void) setContentID:(NSString *)contentID
{
    if (_base.contentType.isMultipart)
        _base.contentID = contentID;
    else
        self.rootData.contentID = contentID;
}

-(NSString *) contentID
{
    if (_base.contentType.isMultipart)
        return _base.contentID;
    else
        return self.rootData.contentID;
}

-(NSString *)boundary
{
    return _base.contentType.boundary;
}

-(void)setBoundary:(NSString *)boundary
{
    _base.contentType.boundary = boundary;
}

-(void) setTransferEncoding:(MIMETransferEncodingStyle)transferEncoding
{
    if (_base.contentType.isMultipart)
        _base.transferEncoding = transferEncoding;
    else
        self.rootData.transferEncoding = transferEncoding;
}

-(MIMETransferEncodingStyle) transferEncoding
{
    if (_base.contentType.isMultipart)
        return _base.transferEncoding;
    else
        return self.rootData.transferEncoding;
}

#pragma mark - MIME Part Handling

-(PKMIMEMessage *) root
{
    return [self partAtIndex:_rootIndex];
}

-(PKMIMEData *) rootData
{
    return [self partDataAtIndex:_rootIndex];
}

-(BOOL) setRootContentID:(NSString *)rootContentID
{
    if ([rootContentID length] <= 0)
        return NO;
    
    for (int i = 0; i < _parts.count; i++)
    {
        PKMIMEData *part = [_parts objectAtIndex:i];
        if ([part.contentID isEqualToString:rootContentID])
            return [self setRootIndex:i];
    }    
    return NO;
}

-(BOOL) setRootIndex:(NSUInteger)index
{
    if (index <= self.numParts)
    {
        _rootIndex = index;
        return YES;
    }
    return NO;
}

-(NSString *)rootContentID
{
    return [self root].contentID;
}

-(PKMIMEMessage *) partWithID:(NSString *)partID
{
    for (PKMIMEData *part in _parts)
    {
        if ([part.contentID isEqualToString:partID])
            return [PKMIMEMessage messageWithData:part];
    }
    return nil;
}

-(PKMIMEData *) partDataWithID:(NSString *)partID
{
    for (PKMIMEData *part in _parts)
    {
        if ([part.contentID isEqualToString:partID])
            return part;
    }
    return nil;
}

-(PKMIMEMessage *) partAtIndex:(NSUInteger)index
{
    if (index <= self.numParts)
        return [PKMIMEMessage messageWithData:[_parts objectAtIndex:index]];
    
    return nil;
}

-(PKMIMEData *) partDataAtIndex:(NSUInteger)index
{
    if (index <= self.numParts)
        return [_parts objectAtIndex:index];
    
    return nil;    
}

-(void) addPart:(PKMIMEData *)data
{
    [_parts addObject:data];
}

-(NSUInteger) numParts
{
    return _parts.count;
}

#pragma mark - multipart/alternative Handling

-(NSUInteger) numAlternatives
{
    if ((_base.contentType.isMultipart) && ([_base.contentType.subType.lowercaseString isEqualToString:@"alternative"]))
        return _parts.count;
    else
        return 0;
}

-(BOOL) hasAlternatives
{
    return (self.numAlternatives > 0);
}

-(NSArray *) alternatives
{
    if (!self.hasAlternatives)
        return nil;
    
    NSMutableArray *alts = [NSMutableArray arrayWithCapacity:_parts.count];
    for (PKMIMEData *part in _parts)
        [alts addObject:part.contentType];

    return alts;
}

-(PKMIMEData *) dataForAlternative:(PKContentType *)alternativeContentType;
{
    for (long i = _parts.count-1; i >= 0 ; i--)
    {
        PKMIMEData *part = [_parts objectAtIndex:i];
        if ([part.contentType.string isEqualToString:alternativeContentType.string])
            return part;
    }
    return nil;
}

-(PKMIMEData *) dataForAlternativeNumber:(NSUInteger)alternativeIndex
{
    return [self partDataAtIndex:alternativeIndex];
}

-(PKMIMEData *) dataForBestAlternative
{
    PKMIMEMessage *altMessage = self.root;
    
    while (altMessage.hasAlternatives)
        altMessage = altMessage.root;

    return altMessage.rootData;
}

#pragma mark - Data Output

/**
 * Ensure that header values reflect current state of data
 * Should be called before creating MIME message header text
 **/
-(void) prepareMessageHeadersForContent:(NSData *)content
{
    if (_base.contentType.isMultipart)
    {
        [_base.headers setValue:@"1.0" forKey:@"MIME-Version"];
        [_base.headers setValue:[NSString stringWithFormat:@"%lu", (unsigned long)content.length] forKey:@"Content-Length"];
        
        if ([[_base.contentType.subType lowercaseString] isEqualToString:@"related"])
        {
            // Make sure we have the proper starting ContentID correct (per RFC 2112)
            if (self.rootData.contentID.length == 0)
                self.rootData.contentID = [NSString stringWithFormat:@"%@", [NSString stringWithNewGUID]];
            [_base.contentType setParameterWithName:@"start" andValue:[NSString stringWithFormat:@"<%@>", self.rootData.contentID]];
            
            // Make sure we have the proper start-info type
            NSString *rootType = [self.rootData.contentType parameterWithName:@"type"];
            if (rootType.length == 0)
                rootType = self.rootData.contentType.mediaType;
            [_base.contentType setParameterWithName:@"start-info" andValue:rootType];
            
            // Set the type parameter to our root's mediaType (per RFC 2112)
            [_base.contentType setParameterWithName:@"type" andValue:self.rootData.contentType.mediaType];
        }    
        [_base.headers setValue:_base.contentType.string forKey:@"Content-Type"];
        [_base.headers setValue:[NSData stringForTransferEncodingStyle:_base.transferEncoding] forKey:@"Content-Transfer-Encoding"];
        
    }
    else
    {
        // Not multipart; use root headers
        [self.rootData.headers setValue:@"1.0" forKey:@"MIME-Version"];
    }    
}

-(NSData *) rawData
{
    NSMutableData *content = [[NSMutableData alloc] init];
    
    if (_base.contentType.isMultipart)
    {
        /** Add the first (root) part, with headers **/
        NSString *strBoundary = [NSString stringWithFormat:@"\r\n\r\n--%@\r\n", _base.contentType.boundary];
        [content appendData:[strBoundary dataUsingEncoding:NSUTF8StringEncoding]];
        [content appendData:[self.rootData.headerStrings dataUsingEncoding:NSUTF8StringEncoding]];
        [content appendData:[@"\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
        [content appendData:self.rootData.rawData];
        
        /** Add all subparts, with headers **/
        for (int i = 1; i < _parts.count; i++)
        {
            PKMIMEData *part = [_parts objectAtIndex:i];
            
            NSString *strBoundary = [NSString stringWithFormat:@"\r\n--%@\r\n", _base.contentType.boundary];
            [content appendData:[strBoundary dataUsingEncoding:NSUTF8StringEncoding]];
            [content appendData:[part.headerStrings dataUsingEncoding:NSUTF8StringEncoding]];
            [content appendData:[@"\r\n" dataUsingEncoding:NSUTF8StringEncoding]];
            [content appendData:part.data];            
        }
        
        /** Final boundary String **/
        strBoundary = [NSString stringWithFormat:@"\r\n--%@--\r\n", _base.contentType.boundary];
        [content appendData:[strBoundary dataUsingEncoding:NSUTF8StringEncoding]];
    }
    else
        [content appendData:self.rootData.rawData];
    [self prepareMessageHeadersForContent:content];
    
    return content;
}

-(NSData *) data
{
    MIMETransferEncodingStyle dataEncoding = _base.transferEncoding;
    if (!_base.contentType.isMultipart)
        dataEncoding = self.rootData.transferEncoding;
    NSData *encodedData = [[self rawData] encodeToStyle:dataEncoding];
    [self prepareMessageHeadersForContent:encodedData];
    return encodedData;
}

#pragma mark - String Output

-(NSString *) headerStrings
{
    if (_base.contentType.isMultipart)
        return _base.headerStrings;
    else
        return self.rootData.headerStrings;
}

-(NSString *) headerStringsForDisplay
{
    if (_base.contentType.isMultipart)
        return _base.headerStringsForDisplay;
    else
        return self.rootData.headerStringsForDisplay;
}

-(NSString *) messageString
{
    NSData *data = self.data;
	return [[NSString alloc] initWithBytes:[data bytes] length:[data length] encoding:self.contentType.charSetEncoding];
}

-(NSString *) messageStringWithHeaders
{
    return [NSString stringWithFormat:@"%@\r\n%@", self.headerStrings, self.messageString];
}

@end
