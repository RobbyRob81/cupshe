//
//  NSData+MIMETransferEncoding.m
//
//  Created by Jeff Hay on 3/28/12.
//  Copyright (c) 2012 Portable Knowledge, LLC. All rights reserved.
//
// Portable Knowledge Open Source Component License - Version 1.0 - April 13th, 2012
// 
// Permission is hereby granted, free of charge, to any person or organization`
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.  IN NO CASE DOES THE USE OF THIS SOFTWARE EXPRESS
// OR IMPLY ANY PARTNERSHIP OR COOPERATION WITH THE AUTHORS OR COPYRIGHT HOLDERS
// OF THIS SOFTWARE.


#import "NSData+MIMETransferEncoding.h"

#import "NSData+Base64.h"

@implementation NSData (MIMETransferEncoding)

#pragma mark - Encoding Style type translation

+(MIMETransferEncodingStyle) transferEncodingStyleFromString:(NSString *)encodingStyleString
{
    if ([encodingStyleString length] == 0)
        return MIMETransferEncodingStyle7Bit;  // per RFC, a missing style type should be treated as 7Bit
    
    NSString *lowerStyle = [encodingStyleString lowercaseString];

    if ([lowerStyle isEqualToString:@"7bit"])
        return MIMETransferEncodingStyle7Bit;

    if ([lowerStyle isEqualToString:@"8bit"])
        return MIMETransferEncodingStyle8Bit;

    if ([lowerStyle isEqualToString:@"base64"])
        return MIMETransferEncodingStyleBase64;
    
    if ([lowerStyle isEqualToString:@"binary"])
        return MIMETransferEncodingStyleBinary;
    
    if ([lowerStyle isEqualToString:@"identity"])
        return MIMETransferEncodingStyleIdentity;

    if ([lowerStyle isEqualToString:@"quoted-printable"])
        return MIMETransferEncodingStyleQuoted;

    return MIMETransferEncodingStyleOther;
}

-(MIMETransferEncodingStyle) transferEncodingStyleFromString:(NSString *)encodingStyleString
{
    return [[self class] transferEncodingStyleFromString:encodingStyleString];
}

+(NSString *) stringForTransferEncodingStyle:(MIMETransferEncodingStyle)encodingStyle
{
    switch (encodingStyle)
    {
        case MIMETransferEncodingStyle7Bit:
            return @"7bit";
        case MIMETransferEncodingStyle8Bit:
            return @"8bit";
        case MIMETransferEncodingStyleBase64:
            return @"base64";
        case MIMETransferEncodingStyleBinary:
            return @"binary";
        case MIMETransferEncodingStyleIdentity:
            return @"identity";
        case MIMETransferEncodingStyleQuoted:
            return @"quoted-printable";
        default:
            return nil;
    }
}

-(NSString *) stringForTransferEncodingStyle:(MIMETransferEncodingStyle)encodingStyle
{
    return [[self class] stringForTransferEncodingStyle:encodingStyle];
}

#pragma mark 7bit/8bit Encoding/Decoding

-(NSData *) stripCRLF
{
    NSMutableData *data = [[NSMutableData alloc] initWithCapacity:self.length];
    
    NSUInteger length = self.length;
    unsigned char *buffer;
    
    buffer = malloc(length);
    [self getBytes:buffer];
    for (unsigned i = 0; i < length; i++)
    {
        unsigned char byte = buffer[i];
        if ((byte != 10) && (byte != 13))
            [data appendBytes:&byte length:1];
    }    
    free(buffer);
    
    return [NSData dataWithData:data];
}

-(NSData *) insertCRLFandStripNULs:(BOOL)shouldMake7Bit
{
    NSMutableData *data = [[NSMutableData alloc] initWithCapacity:(self.length * 1.20)]; // assume about 20% growth
    
    NSUInteger length = self.length;
    unsigned char *buffer;
    
    buffer = malloc(length);
    [self getBytes:buffer];
    unsigned linechars = 0;
    for (unsigned i = 0; i < length; i++)
    {
        unsigned char byte = buffer[i];
        if ((byte != 0) && (byte != 10) && (byte != 13))
        {
            if ((!shouldMake7Bit) || (byte < 128))
            {
                [data appendBytes:&byte length:1];
                linechars = linechars + 1;
                if (linechars > 949)
                {
                    static unsigned char CRLF[2] = {13, 11};
                    [data appendBytes:CRLF length:2];
                    linechars = 0;
                }
            }
        }
    }    
    free(buffer);
    
    return [NSData dataWithData:data];
}

-(NSData *) encodeTo7Bit
{
    return [self insertCRLFandStripNULs:YES];
}

-(NSData *) decodeFrom7Bit
{
    return [self stripCRLF];
}

-(NSData *) encodeTo8Bit
{
    return [self insertCRLFandStripNULs:NO];
}

-(NSData *) decodeFrom8Bit
{
    return [self stripCRLF];
}

#pragma mark Base64 Encoding/Decoding

-(NSData *) decodeFromBase64
{
    NSString *strData = [[NSString alloc] initWithData:self encoding:NSUTF8StringEncoding];
    NSData *data = [NSData dataFromBase64String:strData];
    return data;
}

-(NSData *) encodeToBase64
{
    NSString *strData = [self base64EncodedString];
    return [strData dataUsingEncoding:NSUTF8StringEncoding];
}

#pragma mark Quoted-Printable Encoding/Decoding

// Translate the input "byte" from an ASCII hex digit to the decimal value.
// Returns 255 on conversion error
static unsigned char hexByte(unsigned char byte)
{
    if (byte < '0')
        return 255;
    
    if (byte <= '9')
        return byte - '0';
    
    if ((byte >= 'a') && (byte <= 'f'))
        return 10 + (byte - 'a');
    
    if ((byte >= 'A') && (byte <= 'F'))
        return 10 + (byte - 'A');
    
    return 255;
}

-(NSData *) decodeFromQuotedPrintable
{
    NSMutableData *data = [[NSMutableData alloc] initWithCapacity:self.length]; 
    NSUInteger length = self.length;
    unsigned char *buffer;
    
    buffer = malloc(length);
    [self getBytes:buffer];
    for (unsigned i = 0; i < length; i++)
    {
        unsigned char byte = buffer[i];
        
        if ((byte == '=') && (i < (length - 2)))
        {
            unsigned char nextByte = buffer[++i];
            unsigned char nextNextByte = buffer[++i];
            
            if ((nextByte == 13) && (nextNextByte == 11))
            {
                // Soft Line Break: nothing to decode here
            }
            else 
            {
                unsigned char nByte = hexByte(nextByte);
                unsigned char nnByte = hexByte(nextNextByte);
                
                if ((nByte == 255) || (nnByte == 255))
                {                    
                    // Invalid hex digits found after an '='.  This is not valid quoted-printable
                    NSLog(@"Warning: Invalid escape characters found in quoted-printable decoding; decoded as literals");
                    unsigned char rawBytes[3];
                    rawBytes[0] = '=';
                    rawBytes[1] = nextByte;
                    rawBytes[2] = nextNextByte;
                    [data appendBytes:rawBytes length:3];
                }
                else
                {
                    unsigned char dataByte = ((nByte << 4) | nnByte);
                    [data appendBytes:&dataByte length:1];
                }
            }   
        }
        else
            // Literal Representation: Decoded character is the same as encoded
            [data appendBytes:&byte length:1];  
    }    
    free(buffer);
    
    return [NSData dataWithData:data];
}

-(NSData *) encodeToQuotedPrintable:(BOOL)isText
{
    // Assume encoded data will be 30% larger than decoded
    NSMutableData *data = [[NSMutableData alloc] initWithCapacity:(self.length * 1.3)];
    
    static unsigned char HexChars[16] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
    
    NSUInteger length = self.length;
    unsigned char *buffer;
    
    buffer = malloc(length);
    [self getBytes:buffer];
    unsigned linechars = 0;
    for (unsigned i = 0; i < length; i++)
    {
        BOOL encoded = NO;
        unsigned char byte = buffer[i];
        
        // Literal Representation: certain octets can be "encoded" literally
        if (((byte >= 33) && (byte <= 60)) || ((byte >= 62) && (byte <= 126)))
        {
            [data appendBytes:&byte length:1];
            linechars += 1;
            encoded = YES;
        }
        
        // White Space: if whitespace characters can only be literally encoded
        //  if they will not occur at the end of a line
        if (((byte == 9) || (byte == 32)) && (linechars < 73))
        {
            [data appendBytes:&byte length:1];
            linechars += 1;
            encoded = YES;
        }
        
        if (isText)
        {
            // Line Breaks: In text encoding, newlines should be encoded as CRLF
            static unsigned char CRLF[2] = {13, 11};
            if ((byte == '\r') && ((i+1 < length) && (buffer[i+1] == '\n')))
            {
                [data appendBytes:CRLF length:2];
                linechars += 2;
                i++;
                encoded = YES;
            }
            else if (byte == '\n')
            {
                [data appendBytes:CRLF length:2];
                linechars += 2;
                encoded = YES;
            }
        }
        // General 8bit representation: "=XX" where XX is a hex value
        if (!encoded)
        {
            static char byteCode[3] = {'=', 'X', 'X'};
            byteCode[1] = HexChars[(byte & 0x0F0) >> 4];
            byteCode[2] = HexChars[(byte & 0x00F)];
            [data appendBytes:byteCode length:3];
            linechars += 3;
            encoded = YES;
        }
        
        // Soft Line Breaks: Line can not be longer than 76 characters, not
        // counting the final CRLF
        if (linechars >= 74)
        {
            static char softBreak[3] = {'=', 13, 11};
            [data appendBytes:softBreak length:3];
            linechars = 0;
        }
    }    
    free(buffer);
    
    return [NSData dataWithData:data];
}

#pragma mark General Encoding/Decoding Methods

-(NSData *) encodeToStyle:(MIMETransferEncodingStyle)encodingStyle
{
    switch (encodingStyle)
    {
        case MIMETransferEncodingStyle7Bit:
            return [self encodeTo7Bit];
        case MIMETransferEncodingStyle8Bit:
            return [self encodeTo8Bit];
        case MIMETransferEncodingStyleBase64:
            return [self encodeToBase64];
        case MIMETransferEncodingStyleBinary:
        case MIMETransferEncodingStyleIdentity:
            return self;
        case MIMETransferEncodingStyleQuoted:
            return [self encodeToQuotedPrintable:NO];
        default:
            return nil;
    }
}

-(NSData *) decodeFromStyle:(MIMETransferEncodingStyle)encodingStyle
{
    switch (encodingStyle)
    {
        case MIMETransferEncodingStyle7Bit:
        case MIMETransferEncodingStyle8Bit:
            return [self stripCRLF];
        case MIMETransferEncodingStyleBase64:
            return [self decodeFromBase64];
        case MIMETransferEncodingStyleBinary:
        case MIMETransferEncodingStyleIdentity:
            return self;
        case MIMETransferEncodingStyleQuoted:
            return [self decodeFromQuotedPrintable];
        default:
            return nil;
    }
}

@end
