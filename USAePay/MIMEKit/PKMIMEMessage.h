//
//  PKMIMEMessage.h
//
//  Created by Jeff Hay on 3/29/12.
//  Copyright (c) 2012 Portable Knowledge, LLC. All rights reserved.
//
// Portable Knowledge Open Source Component License - Version 1.0 - April 13th, 2012
// 
// Permission is hereby granted, free of charge, to any person or organization`
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.  IN NO CASE DOES THE USE OF THIS SOFTWARE EXPRESS
// OR IMPLY ANY PARTNERSHIP OR COOPERATION WITH THE AUTHORS OR COPYRIGHT HOLDERS
// OF THIS SOFTWARE.

#if !TARGET_OS_MAC
#import <UIKit/UIKit.h>
#endif

#import "PKMIMEData.h"

/**
 * High-level class for creating and reading MIME messages.
 *
 * `PKMIMEMessage` encapsulates a complete MIME message, including headers and data bytes for multipart MIME messages.  `PKMIMEMessage` can be 
 * used to create or read multipart MIME message, with each part represented by a `PKMIMEData` object.  (Note that MIME messages can be recursive, 
 * so each `PKMIMEData` part may itself be a multipart MIME message that should be parsed with via a new `PKMIMEMessage` instance).  Each part may 
 * have its own encoding and content type, as specified in headers associated with the part.  In addition, `PKMIMEMessage` allows for encoding and 
 * decoding the entire MIME message with a seperate encoding.
 * 
 * All `PKMIMEMessage` objects are mutable.
 */

@interface PKMIMEMessage : NSObject
{
    PKMIMEData *_base;

    NSMutableArray *_parts;
    NSInteger _rootIndex;
}

/** 
 * The transfer encoding used for this entire message.  
 *
 * This is the format of the data bytes as transferred (i.e., in an email or HTTP request/response). The default value is 
 * `MIMETransferEncodingStyleBinary`; `MIMETransferEncodingStyleBase64` is very often the format used in HTTP request/response calls.
 */
@property (nonatomic) MIMETransferEncodingStyle transferEncoding;

/** 
 * The MIME Content-Type of the entire message.  
 *
 * For multipart messages, this should be "`multipart/xxxx`", where `xxxx` indicates the exact relation of the parts.  For single-part
 * messages, this specifies the kind of data (text, image, etc) as well as format (JPG, UTF8, etc.) 
 */
@property (weak, nonatomic, readonly) PKContentType *contentType;

/**
 * MIME Content-ID string specified for entire message.
 *
 * This can be thought of as the "name" of the data (often a filename, etc.) 
 */
@property (nonatomic, strong) NSString *contentID;

/** 
 * Dictionary containing MIME header information associated with the entire message.  
 *
 * In the MIME ecoding, headers appear as `Name:Value` pairs on individiual lines before the encoded data.  For instance,
 *
 *    `Content-ID: "Hello"`
 *
 *  In the headers dictionary, the header value (`"Hello"`) is an NSString value stored for the key name (`"Content-ID"`)
 *
 *  @warning Header strings currently are expected to ONLY contain UTF-8 strings, with no encoding (this is *not* fully MIME-compliant)
 **/
@property (weak, nonatomic, readonly) NSMutableDictionary *headers;

/**
 * Unqiue string used to seperate the parts in multipart MIME messages.
 *
 * For newly-created messages, the default value is generated via a UUID.  For parsing messages, the boundary is required to be
 * specified in the message's `Content-Type` header by [RFC 2045](http://tools.ietf.org/html/rfc2045)
 *
 * This may be set to any string known to be unique to the encoded version of the message body
 **/
@property (nonatomic, copy) NSString *boundary;

/** @name MIME Message Creation */

/**
 * Create a new, empty MIME Message
 *
 * Initializes a new MIME message with all default values.  Useful for creating new MIME messages.
 *
 * \returns A container for a MIME message with zero parts
 **/
-(id) init;

/**
 * Create a new, empty MIME Message with the given _contentType_
 *
 * Initializes a new MIME message with all default values, and set the overall message contentType to _contentType_.
 * Useful for creating new MIME messages.
 *
 * \returns A container for a MIME message with zero parts
 **/
-(id) initWithContentType:(PKContentType *)contentType;

/**
 * Create a new MIME message from the given _data_
 *
 * Creates a MIME message by reading the decoded _data_ and its associated headers.  If _data_ represents a multipart MIME message, seperates
 * the message into parts which can be read with the root, partWithID:, partDataWithID:, partAtIndex:, and partDataAtIndex: methods.  
 * If _data_ represents a single-part MIME message, the root method of the returned `PKMIMEMessage` object will return a copy of _data_.
 *
 * \returns PKMIMEMessage instance initialized with _data_
 **/
+(PKMIMEMessage *) messageWithData:(PKMIMEData *)data;

/** @name Adding Parts */

/**
 * Add a `PKMIMEData` object as a part of the entire MIME message
 *
 * Adds the part to the MIME message.  MIME message part ordering may or may not be sensitive to order; the order of part addition is
 * preserved when the MIME message is generated.  Unless otherwise specified, the root part of the message is assumed to be the first part
 * added.
 *
 * This method can be used to easily generate multipart MIME messages - just add each part as needed, and make the contentType indicates
 * `multipart`.  If creating a `multipart/alternative` message, not that according to [RFC 2045](http://tools.ietf.org/html/rfc2045),
 * alternatives _should_ be defined from "least-best" representation to "best" (i.e., `text/plain` will be defined before `text/html`).
 * Part definition order is preserved, so it is up to the caller to add parts in order from least-faithful alternative to most-faithful.
 *
 * \param data MIME data to add to the message.
 */
-(void) addPart:(PKMIMEData *)data;

/** @name Querying Parts */

/**
 * The number of parts this message has.
 *
 * This should always be `1` for messages with a contentType that doesn't indicate `multipart`.
 *
 * \return The number of parts in the MIME message, including the root
 **/
-(NSUInteger) numParts;

/**
 * Read the message part with _partID_ specified in it's `Content-ID` header
 *
 * Scans all parts in the message for a part with a `Content-ID` header that exactly matches _partID_ (using `isEqualToString:`).  If found,
 * parses that part as a complete MIME message and returns the resulting `PKMIMEMessage` instance (thus handling nested multipart MIME messages).
 * To return just the MIME data, use partDataWithID:.
 *
 * \return A `PKMIMEMessage` instance initialized with the data from the part with a `Content-ID` matching _partID_, or `nil` if no match found.
 * \sa partDataWithID:
 **/
-(PKMIMEMessage *) partWithID:(NSString *)partID;

/**
 * Read the message part at the specified _index_
 *
 * Finds the message part at the specified _index_, parses that part as a complete MIME message and returns the resulting `PKMIMEMessage` 
 * instance (thus handling nested multipart MIME messages).  To return just the MIME data, use partDataAtIndex:.
 *
 * \return A `PKMIMEMessage` instance initialized with the data from the part at _index_, or `nil` if _index_ is out of range.
 * \sa partDataAtIndex:
 **/
-(PKMIMEMessage *) partAtIndex:(NSUInteger)index;

/**
 * Retreive the message part data with _partID_ specified in it's `Content-ID` header
 *
 * Scans all parts in the message for a part with a `Content-ID` header that exactly matches _partID_ (using `isEqualToString:`).  If found,
 * returns the data as a `PKMIMEData` instance. To parse the data as a MIME message, use partWithID:.
 *
 * @warning partDataWithID: **always** returns the data for the entire part message data, even if that part is itself a `multipart` message.
 * In particular, this means for `multipart/alternative` message parts, the data returned is the encapsulation of all alternatives.  For this 
 * reason, you may want to use partWithID: and check the returned message's hasAlternatives method instead of partWithID:.
 *
 * \return A `PKMIMEData` instance initialized with the data from the part with a `Content-ID` matching _partID_, or `nil` if no match found.
 * \sa partWithID:
 * \sa hasAlternatives
 **/
-(PKMIMEData *) partDataWithID:(NSString *)partID;

/**
 * Retreive the message part data at the specified _index_
 *
 * Finds the message part at the specified index, and returns a `PKMIMEData` instance with the part data.  To parse the data as a MIME message, 
 * use partAtIndex:.
 *
 * @warning partDataAtIndex: **always** returns the data for the entire part message data, even if that part is itself a `multipart` message.
 * In particular, this means for `multipart/alternative` message parts, the data returned is the encapsulation of all alternatives.  For this 
 * reason, you may want to use partAtIndex: and check the returned message's hasAlternative method instead of partDataAtIndex:.
 *
 * \return A `PKMIMEData` instance initialized with the data from the part at _index_, or `nil` if _index_ is out of range.
 * \sa partAtIndex:
 * \sa hasAlternatives
 **/
-(PKMIMEData *) partDataAtIndex:(NSUInteger)index;

/**
 * Retreive the root part for the message
 *
 * Some multipart MIME messages have a concept of a `root` part, or the main message part (i.e., in a `multipart/related` message, the root
 * part contains the primary message content, which refers to the other parts via `Content-ID`s.  The root part index can vary depending on
 * the particulars of the message format.  This method always returns the full MIME message for the root of the message (in single-part messages, 
 * this is always equivilent to `partAtIndex:0`).
 *
 * \return A `PKMIMEMessage` instance initialized with the root message part
 * \sa rootData
 * \sa partAtIndex:
 **/
-(PKMIMEMessage *) root;

/**
 * Retreive the root data for the message
 *
 * Some multipart MIME messages have a concept of a `root` part, or the main message part (i.e., in a `multipart/related` message, the root
 * part contains the primary message content, which refers to the other parts via `Content-ID`s.  The root part index can vary depending on
 * the particulars of the message format.  This method always returns the data for the root of the message (in single-part messages, this is
 * always equivilent to `partDataAtIndex:0`).
 *
 * @warning rootData **always** returns the data for the entire root message data, even if the root is itself a `multipart` message.
 * In particular, this means for `multipart/alternative` roots, the data returned is the encapsulation of all alternatives.  For this 
 * reason, you may want to use dataForBestAlternative instead.
 *
 * \return A `PKMIMEData` instance initialized with the data from the root message part
 * \sa root
 * \sa partDataAtIndex:
 **/
-(PKMIMEData *) rootData;

/** @name Root Part Manipulation */

/**
 * Sets the root message part to the part with a contentID matching _rootContentID_
 *
 * The default root message part is the part at index 0.  If some other part should be used, this method can be called to set the root
 * message part to the part with a `Content-ID` header matching _rootContentID_.  If no match is found, or if _rootContentID_ is an empty
 * or `nil` string, the root part is not changed (and `NO` is returned).
 *
 * \param rootContentID The contentID of the root message part
 * \returns YES if new root part was found, NO if no matching part found (in which case, the root part wasn't changed)
 **/
-(BOOL) setRootContentID:(NSString *)rootContentID;

/**
 * Sets the root message part to the part to the part at _index_
 *
 * The default root message part is the part at index 0.  If some other part should be used, this method can be called to set the root
 * message part to the part at the specified _index_.  If _index_ exceeds the number of parts, the root part is not changed.
 *
 * \param index The index of the root message part
 * \returns YES if new root part was changed, NO if _index_ is out of bounds (in which case, the root part wasn't changed)
 **/
-(BOOL) setRootIndex:(NSUInteger)index;

/**
 * Retreive the contentID of the root message part
 * \returns The contentID of the root message part, or `nil` if the root message part doesn't have a `Content-ID` header
 **/
-(NSString *) rootContentID;

/** @name multipart/alternative Message Parsing */

/**
 * Retreive the number of alternative parts in this MIME message
 *
 * MIME messages of `multipart/alternative` contentType contain several alternative parts for the same message (for example, `text/html',
 * 'text/plain', etc.).  This method will return the number of possible alternatives for this message, if the message is `multipart/alternative`'.
 * If the receiver's contentType is anything else, 0 is always returned.
 *
 * \returns The number of possible alternative formats for this message
 **/
-(NSUInteger) numAlternatives;

/**
 * Is the message `multipart/alternative`?
 *
 * Returns `YES` if the receiver is a `multipart/alternative` MIME message and has at least one alternative defined (one part).  This is the same
 * as `numAlternatives` `> 0`.
 *
 * \returns `YES` if the receiver has at least one alternative encoding
 **/
-(BOOL) hasAlternatives;

/**
 * Retreive array of all possible alternative contentTypes, or `nil` if no alternatives exist
 *
 * Each element in the returned array is a `PKContentType` object containing the full contentType for one possible alternative for the message.
 * The array of contentTypes is returned in the order the alternatives are defined.  According to [RFC 2045](http://tools.ietf.org/html/rfc2045),
 * alternatives SHOULD be defined from "least-best" representation to "best" (i.e., `text/plain` will be defined before `text/html`).  As such, the
 * last alternative in the array is the most faithful representation of the message.
 *
 * \returns NSArray of `PKContentType` objects for all alternative representations of the message, in increasing order of preference.  `nil` if
 * no alternatives are found.
 **/
-(NSArray *) alternatives;

/**
 * Return the data for the alternative with the given contentType
 *
 * Searches all alternative parts for a contentType exactly matching _alternativeContentType_.  If an exact match is found, returns the data for
 * the alternative part.  Otherwise, returns `nil`.
 *
 * The objects returned in the `alternatives` array can be as `alternativeContentType`.
 *
 * \return Data for the selected alternative message part, or `nil`.
 * \sa alternatives
 * \sa dataForAlternativeNumber:
 **/
-(PKMIMEData *) dataForAlternative:(PKContentType *)alternativeContentType;

/**
 * Return the data for the specific alternative part number (0-based)
 *
 * A synonym for the receiver's `partDataAtIndex:` method, returns just the data of the specified alternative number.  Alternatives are numbered
 * starting at 0, so the _alternativeIndex_ is the index into the `alternatives` array.
 *
 * \returns Data for the selected alternative message part, or `nil`.
 * \sa alternatives
 * \sa dataForAlternative:
 **/
-(PKMIMEData *) dataForAlternativeNumber:(NSUInteger)alternativeIndex;

/**
 * Return the best data for an alternative 
 *
 * According to [RFC 2045](http://tools.ietf.org/html/rfc2045), the most-faithful representation of a message should be the last alternative 
 * defined (unless over-ridden in the overall message's contentType header).  In addition, MIME messages may be recusive, so the most-faithful
 * alternative could itself be a `multipart/alternative` MIME message.  This method descends an entire `multipart/alternative` tree until it 
 * finds non-`multipart/alternative` message content, and returns the leaf data.
 *
 * For messages which are not `multipart/alternative`, the tree desention starts at the root part.  For `multipart/alternative` messages, the
 * tree descent starts at the last alternative (unless over-ridden by the contentType header)
 *
 * \returns Data representing the message in the most-faithful manner
 **/
-(PKMIMEData *) dataForBestAlternative;

/** @name MIME Message Generation */

/**
 * Retreive the complete encoded MIME message
 *
 * For multipart messages, this method encodes each message part, in order, to MIME data by calling each part's `data:` method. Then, the entire message 
 * is encoded to an overall MIME message by encoding all parts' data and headers with the encoding specified in the receiver's transferEncoding property.  
 * The returned message is a full MIME message including all headers.  For the message
 * without overall headers, use messageContentString.
 *
 * MIME decoders expect all headers to preceed the encoded data, with each header on a seperate line seperated by `CRLF` characters.  This 
 * method returns an NSString containing all headers in the required format.  As such, the return value from this function is suitable for sending 
 * to a MIME agent.  If reporting to log files, console, etc., it might be better to use messageStringForDisplay. 
 *
 * This method modifies the _headers_ property to contain proper information for the message
 *
 * \returns An `NSString` containing the entire encoded MIME message, suitable for sending to a MIME receiver.
 * \sa messageStringForDisplay
 * \sa messageContentString
 **/
-(NSData *) data;

/**
 * Return a string containing all header strings seperated by `CRLF` characters, suitable for sending
 * to a MIME receiver
 *
 * MIME decoders expect all headers to preceed the encoded data, with each header on a seperate line seperated by `CRLF` characters.  This 
 * method returns an NSString containing all set and calculated headers in the required format.  The string does NOT contain the empty line
 * at the end to seperate MIME headers and data.
 *
 * The return value from this function is suitable for sending to a MIME agent.  If reporting headers to log files, console, etc., it  
 * might be better to use headerStringsForDisplay.
 *
 * @warning Some headers may not contain correct values (i.e., Content-Length) unless the receiver's data or rawData method has been called
 * since changing any object properties or adding/removing message parts.
 *
 * \returns String containing all headers seperated by `CRLF` characters
 * \sa headerStringForDisplay
 **/
-(NSString *) headerStrings;

/**
 * Return a string containing all header strings seperated by just a newline character, suitable for
 * displaying, printing in logs, etc.  
 *
 * MIME decoders expect header lines to seperated by `CRLF` characters, which end up displaying as two newlines when displayed with NSLog()
 * or otherwise printed on MacOS or iOS.  This method returns the same header strings as headerStrings, but seperated by only a single
 * newline character.  This makes for better display, but should **NEVER** be sent to a MIME decoding agent.
 *
 * @warning Some headers may not contain correct values (i.e., Content-Length) unless the receiver's data or rawData method has been called
 * since changing any object properties or adding/removing message parts.
 *
 * \returns String containing all headers seperated by single newline characters
 * @warning Do NOT send this string to a MIME decoder.
 * \sa headerStrings
 **/
-(NSString *) headerStringsForDisplay;

/**
 * Return a string representation of the entire message, if possible
 *
 * Attempts to translate the binary rawData into a string using the encoding suggested by the charSet property of the receiver's contentType.
 * Returns nil on any error in transcoding.
 *
 * \returns String representation of the reciver's MIME message, or nil
 **/
-(NSString *) messageString;

/**
 * Return a string representation of the entire message and all headers, if possible
 *
 * Returns a string representation of the receiver's entire MIME message, including the initial headers to the message.  The headers appear as a 
 * series of `name`=`value` tuples seperated by `CRLF`, and the header block is seperated by the message content by an empty line denoted by `CRLF`.
 * This is a text representation of the message as can be decoded by a MIME receiver, but is only fully valid if the message content can be
 * transcribed to a string (i.e., it is not arbitrary binary content)
 *
 * \returns String representation of the reciver's full MIME message, including all headers
 **/
-(NSString *) messageStringWithHeaders;
@end
